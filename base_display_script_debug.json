{
    "slots":{
        "0":{"name":"slot1","type":{"events":[],"methods":[]}},
        "1":{"name":"slot2","type":{"events":[],"methods":[]}},
        "2":{"name":"slot3","type":{"events":[],"methods":[]}},
        "3":{"name":"slot4","type":{"events":[],"methods":[]}},
        "4":{"name":"slot5","type":{"events":[],"methods":[]}},
        "5":{"name":"slot6","type":{"events":[],"methods":[]}},
        "6":{"name":"slot7","type":{"events":[],"methods":[]}},
        "7":{"name":"switch","type":{"events":[],"methods":[]}},
        "8":{"name":"databank","type":{"events":[],"methods":[]}},
        "9":{"name":"core","type":{"events":[],"methods":[]}},
        "-1":{"name":"unit","type":{"events":[],"methods":[]}},
        "-2":{"name":"construct","type":{"events":[],"methods":[]}},
        "-3":{"name":"player","type":{"events":[],"methods":[]}},
        "-4":{"name":"system","type":{"events":[],"methods":[]}},
        "-5":{"name":"library","type":{"events":[],"methods":[]}}
    },
    "handlers":[
        {"code":"local screenConfig = {\n    vertical = true,\n    titleFontSize = 40,\n    titleHeight = 55,\n    headerRuleHeight = 2,\n    fontSize = 24,\n    xPadding = 5,\n    tableXPadding = 2,\n    rowHeight = 27,\n    rowPadding = 5,\n    countOffset = -90,\n    columns = 2,\n    colspan = 2,\n    tables = {}\n}\nscreenConfig.tables[#screenConfig.tables + 1] = {\n    title = \"Ore\",\n    colspan = 1,\n    rows = {}\n}\nscreenConfig.tables[#screenConfig.tables + 1] = {\n    title = \"Pure\",\n    colspan = 1,\n    rows = {}\n}\nscreenConfig.tables[#screenConfig.tables + 1] = {\n    columns = {\"Tier 1\", \"\"},\n    rows = {\n        {\"Bauxite\", {name = \"Pure Aluminium\", label = \"Aluminium\"}},\n        {\"Coal\", {name = \"Pure Carbon\", label = \"Carbon\"}},\n        {\"Hematite\", {name = \"Pure Iron\", label = \"Iron\"}},\n        {\"Quartz\", {name = \"Pure Silicon\", label = \"Silicon\"}},\n    }\n}\nscreenConfig.tables[#screenConfig.tables + 1] = {\n    columns = {\"Tier 2\", \"\"},\n    rows = {\n        {\"Limestone\", {name = \"Pure Calcium\", label = \"Calcium\"}},\n        {\"Chromite\", {name = \"Pure Chromium\", label = \"Chromium\"}},\n        {\"Malachite\", {name = \"Pure Copper\", label = \"Copper\"}},\n        {\"Natron\", {name = \"Pure Sodium\", label = \"Sodium\"}},\n    }\n}\nscreenConfig.tables[#screenConfig.tables + 1] = {\n    columns = {\"Tier 3\", \"\"},\n    rows = {\n        {\"Petalite\", {name = \"Pure Lithium\", label = \"Lithium\"}},\n        {\"Garnierite\", {name = \"Pure Nickel\", label = \"Nickel\"}},\n        {\"Acanthite\", {name = \"Pure Silver\", label = \"Silver\"}},\n        {\"Pyrite\", {name = \"Pure Sulfur\", label = \"Sulfur\"}},\n    }\n}\nscreenConfig.tables[#screenConfig.tables + 1] = {\n    columns = {\"Tier 4\", \"\"},\n    rows = {\n        {\"Cobaltite\", {name = \"Pure Cobalt\", label = \"Cobalt\"}},\n        {\"Cryolite\", {name = \"Pure Fluorine\", label = \"Fluorine\"}},\n        {{name = \"Gold Nuggets\", label = \"Gold Ngts\"}, {name = \"Pure Gold\", label = \"Gold\"}},\n        {\"Kolbeckite\", {name = \"Pure Scandium\", label = \"Scandium\"}},\n    }\n}\nscreenConfig.tables[#screenConfig.tables + 1] = {\n    columns = {\"Tier 5\", \"\"},\n    rows = {\n        {\"Columbite\", {name = \"Pure Niobium\", label = \"Niobium\"}},\n        {\"Rhodonite\", {name = \"Pure Manganese\", label = \"Manganese\"}},\n        {\"Ilmenite\", {name = \"Pure Titanium\", label = \"Titanium\"}},\n        {\"Vanadinite\", {name = \"Pure Vanadium\", label = \"Vanadium\"}},\n    }\n}\nscreenConfig.tables[#screenConfig.tables + 1] = {\n    colspan = 1,\n    columns = {\"Gasses\"},\n    reverse = true,\n    rows = {\n        {{name = \"Pure Hydrogen\", label = \"Hydrogen\"}},\n        {{name = \"Pure Oxygen\", label = \"Oxygen\"}},\n    }\n}\nscreenConfig.tables[#screenConfig.tables + 1] = {\n    colspan = 1,\n    columns = {\"Catalyst\"},\n    rows = {\n        {\"Catalyst 3\"},\n        {\"Catalyst 4\"},\n        {\"Catalyst 5\"},\n    }\n}\n\nsystem.print(\"=== LIBRARY: Setting up screen config ===\")\nsystem.print(\"slot1 variable exists: \" .. tostring(slot1 ~= nil))\nif slot1 then\n    system.print(\"slot1 type: \" .. type(slot1))\n    if type(slot1) == \"table\" and slot1.getClass then\n        system.print(\"slot1 class: \" .. slot1.getClass())\n    end\nend\n\nif not _G.displays then\n    _G.displays = {}\n    system.print(\"Created new _G.displays table\")\nend\n\nif slot1 then\n    _G.displays[slot1] = screenConfig\n    system.print(\"Set _G.displays[slot1] to screenConfig\")\n    system.print(\"screenConfig has \" .. #screenConfig.tables .. \" tables\")\nelse\n    system.print(\"ERROR: slot1 is nil! Cannot set up display config.\")\n    system.print(\"Make sure you have a screen connected and named 'slot1'\")\nend\n\nlocal displayCount = 0\nfor _ in pairs(_G.displays) do\n    displayCount = displayCount + 1\nend\nsystem.print(\"_G.displays now has \" .. displayCount .. \" entry/entries\")\n","filter":{"args":[],"signature":"onStart()","slotKey":"-5"},"key":"6"},
        {"code":"----------------------------------------\n-- Factory Inventory: Display Manager --\n--        By W3asel (1337joe)         --\n----------------------------------------\n-- Bundled: 2022-11-20T23:53:23Z\n-- Latest version always available here: https://du.w3asel.com/du-factory-inventory\n\n-- exported variables\nlocal elementsReadPerUpdate = 50 --export: The number of elements to process for data collection before the coroutine sleeps.\nlocal maxMassError = 0.001 -- max error allowed for container lookups\n\n-- localize global lookups\nlocal slots = {}\nslots.displays = _G.displays\nslots.containers = _G.containers\nlocal Utilities = _G.Utilities\nlocal InventoryCommon = _G.InventoryCommon\nlocal json = _G.json\nlocal math = _G.math\n\n-- if not found by name will autodetect\nslots.databank = databank\nslots.core = core\n\n-- validate inputs\nlocal screenIndex = 1\nfor slot, _ in pairs(slots.displays) do\n    assert(slot.getClass() == \"ScreenUnit\",\n        string.format(\"Display slot %d is invalid type: %s\", screenIndex, slot.getClass()))\n    slot.activate()\n    screenIndex = screenIndex + 1\nend\n\n-----------------------\n-- End Configuration --\n-----------------------\n\n-- link missing slot inputs / validate provided slots\nlocal module = \"inventory-report\"\nslots.core = Utilities.loadSlot(slots.core, {\"CoreUnitDynamic\", \"CoreUnitStatic\", \"CoreUnitSpace\"}, nil, module, \"core\", false)\nlocal databankOptionalMsg = nil\nif slots.core then\n    databankOptionalMsg = \"Databank link not found, required for reading container data from core.\"\nend\nslots.databank = Utilities.loadSlot(slots.databank, \"DataBankUnit\", nil, module, \"databank\", true, databankOptionalMsg)\n\n-- DEBUG: Check databank connection\nsystem.print(\"=== DATABANK CONNECTION CHECK ===\")\nif slots.databank then\n    system.print(\"Databank connected: YES\")\n    local keyCount = 0\n    for _, key in pairs(slots.databank.getKeyList()) do\n        keyCount = keyCount + 1\n    end\n    system.print(\"Databank has \" .. keyCount .. \" keys\")\n    \n    -- Test a specific key\n    if slots.databank.hasKey(\"hematite\") == 1 then\n        system.print(\"Test: hematite key exists in THIS databank\")\n    else\n        system.print(\"Test: hematite key NOT found in THIS databank\")\n    end\nelse\n    system.print(\"Databank connected: NO - This is the problem!\")\n    system.print(\"Please connect a databank to the programming board.\")\nend\n\n-- hide widget\nunit.hideWidget()\n\n-- define display constants and functions\nlocal RENDER_SCRIPT = [[-- constants\nlocal DEFAULT_FONT = \"Play-Bold\"\n\nlocal FONT = loadFont(DEFAULT_FONT, screenConfig.fontSize)\n\nlocal EMPTY_LABEL = {0.46, 0.46, 0.46, 1}\nlocal FULL_TEXT = {0, 0, 0, 1}\nlocal FULL_LABEL = {0.2, 0.2, 0.2, 1}\nlocal GREEN = {0, 0.5, 0, 1}\nlocal YELLOW = {1, 1, 0, 1}\nlocal RED = {0.5, 0, 0, 1}\nlocal HEADER_RULE = {1, 1, 1, 1}\n\nlocal X_RES, Y_RES = getResolution()\n\nlocal X_START, Y_START, WIDTH\nif screenConfig.vertical then\n    X_START = -Y_RES\n    Y_START = 0\n    WIDTH = Y_RES\nelse\n    X_START = 0\n    Y_START = 0\n    WIDTH = X_RES\nend\n\n-- define functions\n\nlocal function applyTransformation(layer)\n    if screenConfig.vertical then\n        setLayerRotation(layer, -math.pi / 2)\n    end\nend\n\nlocal SI_PREFIXES = {\"\", \"k\", \"M\", \"G\", \"T\", \"P\", \"E\", \"Z\", \"Y\"}\n--- Converts raw float to formatted SI prefix with limited decimal places.\n-- @tparam number value The number to format.\n-- @tparam string units The units label to apply SI prefixes to.\n-- @treturn string The formated number for display.\n-- @treturn string The units with SI prefix applied.\nlocal function printableNumber(value, units)\n    -- can't process nil, 0 breaks the sign calculation\n    if not value or value == 0 then\n        return \"0.0\", units\n    end\n\n    local adjustedValue = math.abs(value)\n    local sign = value / adjustedValue\n    local factor = 1 -- index of no prefix\n    while adjustedValue >= 999.5 and factor < #SI_PREFIXES do\n        adjustedValue = adjustedValue / 1000\n        factor = factor + 1\n    end\n\n    if adjustedValue < 9.95 then -- rounded to 10, show 1 decimal place\n        return string.format(\"%.1f\", sign * math.floor(adjustedValue * 10 + 0.5) / 10), SI_PREFIXES[factor] .. units\n    end\n    return string.format(\"%.0f\", sign * math.floor(adjustedValue + 0.5)), SI_PREFIXES[factor] .. units\nend\n\nlocal function drawRow(layer, barColor, textColor, labelColor, xStart, yStart, width, height, textPadding, title, countOffset, count, units, percent)\n    if barColor and percent <= 0 then\n        return\n    elseif not barColor and percent >= 1 then\n        return\n    end\n\n    local printablePercent = math.floor(percent * 100 + 0.5)\n    percent = math.min(1, percent)\n\n    local canCreateLayers = getRenderCostMax() - getRenderCost() > 150000\n    if not canCreateLayers then\n        textColor = labelColor\n    end\n\n    if barColor then\n        -- new layer to allow for clipping\n        if percent < 1 and canCreateLayers then\n            layer = createLayer()\n            applyTransformation(layer)\n\n            setLayerClipRect(layer, xStart + (1 - percent) * width, yStart, width, height)\n        end\n\n        setNextFillColor(layer, table.unpack(barColor))\n        addBox(layer, xStart + (1 - percent) * width, yStart, percent * width, height)\n    end\n\n    local textHeight = yStart + height * 3 / 4\n\n    setNextTextAlign(layer, AlignH_Left, AlignV_Baseline)\n    setNextFillColor(layer, table.unpack(textColor))\n    addText(layer, FONT, title, xStart + textPadding, textHeight)\n\n    local countX\n    if countOffset < 0 then\n        countX = xStart + width + countOffset - textPadding\n    else\n        countX = xStart + textPadding + countOffset\n    end\n    setNextTextAlign(layer, AlignH_Right, AlignV_Baseline)\n    setNextFillColor(layer, table.unpack(textColor))\n    addText(layer, FONT, count, countX, textHeight)\n    if units:len() > 0 then\n        setNextTextAlign(layer, AlignH_Left, AlignV_Baseline)\n        setNextFillColor(layer, table.unpack(labelColor))\n        addText(layer, FONT, units, countX, textHeight)\n    end\n\n    local percentWidth = getTextBounds(FONT, \"%\")\n    setNextTextAlign(layer, AlignH_Right, AlignV_Baseline)\n    setNextFillColor(layer, table.unpack(textColor))\n    addText(layer, FONT, printablePercent, xStart + width - textPadding - percentWidth, textHeight)\n    setNextTextAlign(layer, AlignH_Right, AlignV_Baseline)\n    setNextFillColor(layer, table.unpack(labelColor))\n    addText(layer, FONT, \"%\", xStart + width - textPadding, textHeight)\nend\n\nlocal function generateRowCell(layer, item, itemConfig, itemData, xStart, yStart, width, height, countOffset)\n    local itemName, itemLabel\n    if type(item) == \"table\" then\n        itemName = string.lower(item.name)\n        itemLabel = item.label or item.name\n    else\n        itemName = string.lower(item)\n        itemLabel = item\n    end\n\n    local itemResults = itemData[itemName] or {}\n    local units = \"\"\n    local count = 0\n    local maxCount = 1\n    local countError = false\n\n    if itemResults.containerMaxItems and itemResults.containerMaxItems > 0 then\n        units = itemResults.units\n        count = itemResults.containerItems\n        maxCount = itemResults.containerMaxItems\n        countError = itemResults.containerError\n    end\n\n    if itemConfig.targetCount then\n        maxCount = itemConfig.targetCount\n    end\n\n    local percent = count / maxCount\n\n    local barColor\n    if itemConfig.reverse then\n        if percent > 0.9 then\n            barColor = RED\n        elseif percent > 0.5 then\n            barColor = YELLOW\n        else\n            barColor = GREEN\n        end\n    else\n        if percent > 0.5 then\n            barColor = GREEN\n        elseif percent > 0.1 then\n            barColor = YELLOW\n        else\n            barColor = RED\n        end\n    end\n\n    local printableCount, countUnits = printableNumber(count, units)\n\n    -- TODO show/test error\n\n    setFontSize(FONT, itemConfig.fontSize)\n\n    drawRow(layer, nil, barColor, EMPTY_LABEL, xStart, yStart, width, height, itemConfig.tableXPadding, itemLabel, countOffset, printableCount, countUnits, percent)\n    drawRow(layer, barColor, FULL_TEXT, FULL_LABEL, xStart, yStart, width, height, itemConfig.tableXPadding, itemLabel, countOffset, printableCount, countUnits, percent)\nend\n\nlocal function inheritConfig(parentConfig, childConfig)\n    local resultConfig = {}\n    for key, value in pairs(parentConfig) do\n        if type(value) ~= \"table\" then\n            resultConfig[key] = value\n        end\n    end\n\n    if type(childConfig) == \"table\" then\n        for key, value in pairs(childConfig) do\n            if type(value) ~= \"table\" then\n                resultConfig[key] = value\n            end\n        end\n    end\n\n    return resultConfig\nend\n\nlocal function generateTable(layer, displayTable, tableConfig, xOffset, yOffset, width, itemData)\n    local title = displayTable.title\n\n    if title then\n        setFontSize(FONT, tableConfig.titleFontSize)\n        setNextTextAlign(layer, AlignH_Center, AlignV_Descender)\n        addText(layer, FONT, title, xOffset + width / 2, yOffset + tableConfig.titleHeight * 3 / 4)\n        yOffset = yOffset + tableConfig.titleHeight\n    end\n\n    local columns\n    if type(displayTable.columns) == \"table\" then\n        columns = #displayTable.columns\n    else\n        columns = displayTable.columns or 1\n    end\n    local columnXPadding = tableConfig.xPadding or tableConfig.xPadding or 0\n\n    local columnWidth = (width - (columns - 1) * columnXPadding) / columns\n    local rowHeight = displayTable.rowHeight or tableConfig.rowHeight\n    local rowPadding = displayTable.rowPadding or tableConfig.rowPadding\n\n    if type(displayTable.columns) == \"table\" then\n        for i, columnHeader in pairs(displayTable.columns) do\n            setFontSize(FONT, tableConfig.fontSize)\n            setNextTextAlign(layer, AlignH_Center, AlignV_Descender)\n            local headerX = xOffset + (i - 1) * (columnWidth + columnXPadding) + columnWidth / 2\n            addText(layer, FONT, columnHeader, headerX, yOffset + tableConfig.rowHeight * 3 / 4)\n        end\n        yOffset = yOffset + rowHeight\n        setNextFillColor(layer, table.unpack(HEADER_RULE))\n        addBox(layer, xOffset, yOffset, width, tableConfig.headerRuleHeight)\n        yOffset = yOffset + tableConfig.headerRuleHeight\n    end\n\n    for _, row in pairs(displayTable.rows) do\n        local rowConfig = inheritConfig(tableConfig, row)\n\n        local column = 0\n        for _, item in pairs(row) do\n            local itemConfig = inheritConfig(rowConfig, item)\n\n            local rowX = xOffset + column * (columnWidth + columnXPadding)\n            generateRowCell(layer, item, itemConfig, itemData, rowX, yOffset, columnWidth, rowHeight, tableConfig.countOffset)\n\n            column = column + 1\n        end\n\n        yOffset = yOffset + rowHeight + rowPadding\n    end\n\n    return yOffset\nend\n\n-- render\n\nlocal baseLayer = createLayer()\napplyTransformation(baseLayer)\n\nlocal yOffset = Y_START\nlocal maxYOffset = 0\n\nlocal columns = screenConfig.columns or 1\nlocal columnWidth = (WIDTH - (columns - 1) * screenConfig.xPadding) / columns\nlocal column = 0\n\nfor _, displayTable in pairs(screenConfig.tables) do\n    local tableConfig = inheritConfig(screenConfig, displayTable)\n\n    local xOffset = X_START + screenConfig.xPadding + column * columnWidth + math.max(0, column - 1) * screenConfig.xPadding\n\n    local colspan = tableConfig.colspan or 1\n    local tableWidth = (WIDTH - screenConfig.xPadding) / columns * colspan - screenConfig.xPadding\n\n    local tableYEnd = generateTable(baseLayer, displayTable, tableConfig, xOffset, yOffset, tableWidth, itemData)\n    maxYOffset = math.max(maxYOffset, tableYEnd)\n    column = column + colspan\n\n    if column >= columns then\n        yOffset = maxYOffset\n        maxYOffset = 0\n        column = 0\n    end\nend\n]]\n\nlocal function populateScreen(screen, screenConfig, itemData)\n    local script = string.format([=[\n        local screenConfig = load(%q)()\n        local itemData = load(%q)()\n        %s]=],\n        \"return \" .. serialize(screenConfig), \"return \" .. serialize(itemData), RENDER_SCRIPT)\n    screen.setRenderScript(script)\nend\n\n-- define data gathering functions\n\n--- Initialize metadata: complete autodetected config fields, prepare for reading/receiving data.\nlocal function initializeMetadata(firstRun)\n    for screen, config in pairs(slots.displays) do\n        if firstRun then\n        -- TODO add loading overlay svg screen\n        end\n\n        -- clear/prep for data\n        config.data = nil\n        config.complete = false\n    end\nend\ninitializeMetadata(true)\n\n-- define class for managing item data\nlocal ItemReport = {}\nfunction ItemReport:new(o)\n    if not o or type(o) ~= \"table\" then\n        o = {}\n    end\n    setmetatable(o, self)\n    self.__index = self\n\n    o.units = \"\"\n\n    -- o.containerData = false\n    o.containerItems = 0\n    o.containerMaxItems = 0\n    o.containerError = nil\n\n    return o\nend\nlocal gatheredItems = {}\n\nlocal function scanContainer(itemData, report)\n    local name = itemData.name\n    if slots.containers and slots.containers[name] and slots.containers[name].getItemsVolume then\n        report.units = \"L\"\n        report.containerItems = slots.containers[name].getItemsVolume()\n        report.containerMaxItems = slots.containers[name].getMaxVolume()\n        report.containerError = nil\n    else\n        system.print(\"Container link not found for \" .. name)\n        report.containerError = true\n    end\nend\n\nlocal resumeOnUpdate = true\nlocal function updateData()\n\n    -- determine necessary data\n    for slot, config in pairs(slots.displays) do\n        for _, table in pairs(config.tables) do\n            for _, row in pairs(table.rows) do\n                for _, item in pairs(row) do\n                    if type(item) == \"table\" then\n                        local report = ItemReport:new(item)\n                        gatheredItems[string.lower(item.name)] = report\n\n                        if item.source == InventoryCommon.constants.SOURCE_CONTAINER_VOLUME_ONLY then\n                            scanContainer(item, report)\n                        end\n                    elseif type(item) == \"string\" then\n                        gatheredItems[string.lower(item)] = ItemReport:new()\n                    else\n                        assert(false, \"Unexpected item type: \" .. tostring(item) .. \" (\" .. type(item) .. \")\")\n                    end\n                end\n            end\n        end\n\n        coroutine.yield()\n        ::continue::\n    end\n\n    -- gather data by databank lookup (containers)\n    system.print(\"=== DEBUG: Checking databank for test ores ===\")\n    local testOres = {\"hematite\", \"quartz\", \"bauxite\", \"coal\"}\n    for _, oreName in ipairs(testOres) do\n        if gatheredItems[oreName] then\n            system.print(\"  \" .. oreName .. \" in gatheredItems: YES\")\n        else\n            system.print(\"  \" .. oreName .. \" in gatheredItems: NO\")\n        end\n        if slots.databank then\n            local hasItemKey = slots.databank.hasKey(oreName)\n            local hasContainerKey = slots.databank.hasKey(oreName .. \".c\")\n            system.print(\"  \" .. oreName .. \" key exists: \" .. tostring(hasItemKey == 1))\n            system.print(\"  \" .. oreName .. \".c key exists: \" .. tostring(hasContainerKey == 1))\n        end\n    end\n    system.print(\"=== Starting databank processing ===\")\n    \n    local elementsRead = 0\n    for name, data in pairs(gatheredItems) do\n        if not slots.databank then\n            break\n        end\n\n        -- read container data using databank values\n        local containerIdListKey = name .. InventoryCommon.constants.CONTAINER_SUFFIX\n        if not (slots.databank.hasKey(name) == 1 and slots.databank.hasKey(containerIdListKey) == 1) then\n            goto continueContainers\n        end\n\n        -- itemName -> unitMass, unitVolume, isMaterial\n        -- itemName.CONTAINER_SUFFIX -> [id, id, id, ...]\n        -- CONTAINER_PREFIX.containerId -> selfMass, maxVolume, optimization\n\n        local itemDetails = json.decode(slots.databank.getStringValue(name))\n\n        local containerIdList = InventoryCommon.jsonToIntList(slots.databank.getStringValue(containerIdListKey))\n        \n        -- DEBUG: Print details for test ores\n        if name == \"hematite\" or name == \"quartz\" or name == \"bauxite\" or name == \"coal\" then\n            system.print(\"DEBUG: Processing \" .. name)\n            system.print(\"  Item details: mass=\" .. tostring(itemDetails.unitMass) .. \", vol=\" .. tostring(itemDetails.unitVolume) .. \", isMat=\" .. tostring(itemDetails.isMaterial))\n            system.print(\"  Container IDs: \" .. slots.databank.getStringValue(containerIdListKey))\n            system.print(\"  Number of containers: \" .. #containerIdList)\n        end\n\n        for _, containerId in pairs(containerIdList) do\n            -- remove container ids that aren't in core.getElementIdList\n            if slots.core.getElementDisplayNameById(containerId) == \"\" then\n                InventoryCommon.removeContainerFromDb(slots.databank, containerId)\n                system.print(string.format(\"Container %d not found in core lookup, removing from databank...\", containerId))\n                goto continueContainerId\n            end\n\n            local containerDetails = json.decode(slots.databank.getStringValue(InventoryCommon.constants.CONTAINER_PREFIX .. containerId))\n\n            local itemMass = (slots.core.getElementMassById(containerId) - containerDetails.selfMass) / containerDetails.optimization\n            local itemCount = itemMass / itemDetails.unitMass\n            local itemUnits\n            local maxItems\n            if itemDetails.isMaterial then\n                itemUnits = \"L\"\n                maxItems = containerDetails.maxVolume\n            else\n                itemUnits = \"\"\n                maxItems = math.floor(containerDetails.maxVolume / itemDetails.unitVolume)\n            end\n\n            data.units = itemUnits\n            -- data.containerData = true\n            data.containerItems = data.containerItems + itemCount\n            data.containerMaxItems = data.containerMaxItems + maxItems\n            data.containerError = data.containerError or math.abs(itemCount - math.floor(itemCount)) > maxMassError\n            \n            -- DEBUG: Show calculations for test ores\n            if name == \"hematite\" or name == \"quartz\" or name == \"bauxite\" or name == \"coal\" then\n                local containerMass = slots.core.getElementMassById(containerId)\n                system.print(string.format(\"  Container %d: totalMass=%.2f, selfMass=%.2f, opt=%.2f\",\n                    containerId, containerMass, containerDetails.selfMass, containerDetails.optimization))\n                system.print(string.format(\"    itemMass=%.2f, itemCount=%.2f, maxItems=%.2f\",\n                    itemMass, itemCount, maxItems))\n                system.print(string.format(\"    TOTAL so far: %.2f / %.2f %s\",\n                    data.containerItems, data.containerMaxItems, itemUnits))\n            end\n\n            elementsRead = elementsRead + 1\n            if elementsRead % elementsReadPerUpdate == 0 then\n                coroutine.yield()\n            end\n\n            ::continueContainerId::\n        end\n\n        ::continueContainers::\n    end\n\n    -- gather data by container links\n\n    -- gather data by industry scanning\n    if slots.core then\n        for _, id in pairs(slots.core.getElementIdList()) do\n            -- system.print(id .. \": \" .. slots.core.getElementNameById(id) .. \": \" .. slots.core.getElementDisplayNameById(id))\n\n            elementsRead = elementsRead + 1\n            if elementsRead % elementsReadPerUpdate == 0 then\n                coroutine.yield()\n            end\n        end\n    end\n\n    -- update screens\n    for slot, config in pairs(slots.displays) do\n        -- skip if already done\n        if config.finished then\n            goto continue\n        end\n\n        populateScreen(slot, config, gatheredItems)\n        config.complete = true\n\n        coroutine.yield()\n        ::continue::\n    end\n\n    resumeOnUpdate = false\n    unit.exit()\nend\n\nlocal updateCoroutine = coroutine.create(updateData)\nfunction _G.resumeWork()\n    -- don't hit coroutine every tick when it's waiting for more data\n    if not resumeOnUpdate then\n        return\n    end\n\n    local ok, message = coroutine.resume(updateCoroutine)\n    if not ok then\n        error(string.format(\"Resuming coroutine failed: %s\", message))\n    end\nend\n\nfunction _G.handleMessage(msg)\n    -- TODO store data as appropriate\n\n    resumeOnUpdate = true\nend","filter":{"args":[],"signature":"onStart()","slotKey":"-1"},"key":"0"},
        {"code":"_G.resumeWork(true)","filter":{"args":[],"signature":"onUpdate()","slotKey":"-4"},"key":"1"},
        {"code":"for _, v in pairs(unit) do\n    if type(v) == \"table\" and v.getClass then\n        if v.getClass() == \"ManualSwitchUnit\" then\n            v.deactivate()\n        end\n    end\nend\n","filter":{"args":[],"signature":"onStop()","slotKey":"-1"},"key":"2"},
        {"code":"--- Utilities module.\n-- Frequently needed utility functions.\n-- @module Utilities\n\n-- Guard to keep this module from reinitializing any time the start event fires if placed in libraries/system slot.\nif _G.Utilities then\n    return\nend\n_G.Utilities = {}\n\nlocal SI_PREFIXES = {\"\", \"k\", \"M\", \"G\", \"T\", \"P\", \"E\", \"Z\", \"Y\"}\n--- Converts raw float to formatted SI prefix with limited decimal places.\n-- @tparam number value The number to format.\n-- @tparam string units The units label to apply SI prefixes to.\n-- @treturn string The formated number for display.\n-- @treturn string The units with SI prefix applied.\nfunction _G.Utilities.printableNumber(value, units)\n    -- can't process nil, 0 breaks the sign calculation\n    if not value or value == 0 then\n        return \"0.0\", units\n    end\n\n    local adjustedValue = math.abs(value)\n    local sign = value / adjustedValue\n    local factor = 1 -- index of no prefix\n    while adjustedValue >= 999.5 and factor < #SI_PREFIXES do\n        adjustedValue = adjustedValue / 1000\n        factor = factor + 1\n    end\n\n    if adjustedValue < 9.95 then -- rounded to 10, show 1 decimal place\n        return string.format(\"%.1f\", sign * math.floor(adjustedValue * 10 + 0.5) / 10), SI_PREFIXES[factor] .. units\n    end\n    return string.format(\"%.0f\", sign * math.floor(adjustedValue + 0.5)), SI_PREFIXES[factor] .. units\nend\n\n--- Finds the first slot on 'unit' that has element class 'slotClass' and is not listed in the exclude list.\n-- @tparam string slotClass The element class pattern of the target slot. May instead be a table containing a list of\n--   class names.\n-- @tparam table exclude A list of slots to exclude from search.\n-- @return The first element found of the desired type, or nil if none is found.\n-- @return The name of the slot where the returned element was found.\nfunction _G.Utilities.findFirstSlot(slotClass, exclude)\n    if type(slotClass) ~= \"table\" then\n        slotClass = {slotClass}\n    end\n    exclude = exclude or {}\n\n    for key, value in pairs(unit) do\n\n        -- ignore excluded elements\n        for _, exc in pairs(exclude) do\n            if value == exc then\n                goto continueOuter\n            end\n        end\n\n        if value and type(value) == \"table\" and value.getClass then\n            for _, class in pairs(slotClass) do\n                if string.match(value.getClass(), class) ~= nil then\n                    return value, key\n                end\n            end\n        end\n\n        ::continueOuter::\n    end\n\n    return nil, nil\nend\n\n-- Verifies the valid argument, if not true then it prints the provided message to the optional screen and to the programming board error log, halting execution.\n-- @param valid The condition to test, typically a boolean.\n-- @tparam string message The message to display on failure.\n-- @tparam ScreenUnit/ScreenSignUnit screen The optional screen for displaying the message on in case of failure.\nlocal function assertValid(valid, message, screen)\n    if not valid then\n        if screen and screen.setCenteredText and type(screen.setCenteredText) == \"function\" then\n            screen.setCenteredText(message)\n        end\n        error(message)\n    end\nend\n\n--- Attempts to verify the provided slot against the expected type, finding missing slot inputs in unit.\n-- @tparam Element provided A named slot that should fill the need for this type. May be nil.\n-- @tparam string targetClass The ElementClass to look for/validate against. May be a table containing a list of classes.\n-- @tparam ScreenUnit/ScreenSignUnit errorScreen A screen to display error messages to on failure.\n-- @tparam string moduleName The name of the module, to help disambiguate problems when multiple modules are run on the same controller.\n-- @tparam string mappedSlotName The internal name of the slot to indicate exactly what mapping failed.\n-- @tparam boolean optional True if this element is optional and should not produce an error on failure to map.\n-- @tparam string optionalMessage A message to print to the console on failure to map an optional element.\nfunction _G.Utilities.loadSlot(provided, targetClass, errorScreen, moduleName, mappedSlotName, optional, optionalMessage)\n    if type(targetClass) ~= \"table\" then\n        targetClass = {targetClass}\n    end\n    local slotName\n\n    local typedSlot = provided\n    if not (typedSlot and type(typedSlot) == \"table\" and typedSlot.getClass) then\n        typedSlot, slotName = _G.Utilities.findFirstSlot(targetClass)\n        if not optional then\n            assertValid(typedSlot, string.format(\"%s: %s link not found.\", moduleName, mappedSlotName), errorScreen)\n        end\n\n        if typedSlot then\n            system.print(string.format(\"Slot %s mapped to %s %s.\", slotName, moduleName, mappedSlotName))\n        elseif optionalMessage and string.len(optionalMessage) > 0 then\n            system.print(string.format(\"%s: %s\", moduleName, optionalMessage))\n        end\n    else\n        local class = typedSlot.getClass()\n        local valid = false\n        for _, tClass in pairs(targetClass) do\n            valid = valid or class == tClass\n        end\n        assertValid(valid, string.format(\"%s %s slot is of type: %s\", moduleName, mappedSlotName, class), errorScreen)\n    end\n    return typedSlot\nend\n\nlocal useParameterSettings = false --export: Toggle this on to override stored preferences with parameter-set values, otherwise will load from databank if available.\n-- can't export value from table, but would rather use it from the utilities object\n_G.Utilities.USE_PARAMETER_SETTINGS = useParameterSettings\n\n--- Returns the preferred preference value, storing that in the databank for future use if available. Type will be inferred from the default value provided.\n-- @param databank The databank to use for preferences.\n-- @tparam string key The databank preference key to look up/store to.\n-- @param defaultValue The value to use if the databank doesn't contain key.\n-- @return The preference value to use.\nfunction _G.Utilities.getPreference(databank, key, defaultValue)\n    local isBool = type(defaultValue) == \"boolean\"\n    local isNumber = type(defaultValue) == \"number\"\n    local prefValue\n\n    if databank then\n        if databank.hasKey(key) == 1 and not _G.Utilities.USE_PARAMETER_SETTINGS then\n            if isBool then\n                prefValue = databank.getIntValue(key) == 1\n            elseif isNumber then\n                prefValue = databank.getFloatValue(key)\n            else\n                prefValue = databank.getStringValue(key)\n            end\n        else\n            prefValue = defaultValue\n        end\n\n        if isBool then\n            local storeValue = 0\n            if prefValue then\n                storeValue = 1\n            end\n            databank.setIntValue(key, storeValue)\n        elseif isNumber then\n            databank.setFloatValue(key, tonumber(prefValue))\n        else\n            databank.setStringValue(key, prefValue)\n        end\n    else\n        prefValue = defaultValue\n    end\n\n    return prefValue\nend\n\nreturn _G.Utilities\n","filter":{"args":[],"signature":"onStart()","slotKey":"-5"},"key":"3"},
        {"code":"--- Common definitions for inventory system.\n\n-- Guard to keep this module from reinitializing any time the start event fires if placed in libraries/system slot.\nif _G.InventoryCommon then\n    return\nend\n_G.InventoryCommon = {}\n\nlocal constants = {}\n-- Container status will be read from core.\nconstants.SOURCE_CORE_CONTAINER = \"core container\"\n-- Container status will be read directly from container by volume.\nconstants.SOURCE_CONTAINER_VOLUME_ONLY = \"container volume\"\n-- suffix of item container keys, format \"<item name>.c\"\nconstants.CONTAINER_SUFFIX = \".c\"\n-- prefix for container metadata keys, format \"c.<id>\"\nconstants.CONTAINER_PREFIX = \"c.\"\n_G.InventoryCommon.constants = constants\n\nfunction _G.InventoryCommon.jsonToIntList(json)\n    local listElements = {}\n\n    for element in string.gmatch(json, \"%d+\") do\n        listElements[#listElements + 1] = tonumber(element)\n    end\n\n    return listElements\nend\n\nfunction _G.InventoryCommon.intListToJson(list)\n    return string.format(\"[%s]\", table.concat(list, \",\"))\nend\n\nlocal CONTAINERS_DB_PATTERN = string.format([[.+%%%s]], constants.CONTAINER_SUFFIX) -- escape . in suffix\n--- Strips the provided container id out of any items that have it listed.\nfunction _G.InventoryCommon.removeContainerFromDb(databank, containerId)\n    local containerList, prefix, suffix, replaceText, changed\n    for _, itemContainer in pairs(databank.getKeyList()) do\n        if not string.match(itemContainer, CONTAINERS_DB_PATTERN) then\n            goto continue\n        end\n        containerList = databank.getStringValue(itemContainer)\n\n        changed = false\n        repeat\n            prefix, suffix = string.match(containerList, \"(%D)%s*\" .. containerId .. \"%s*(%D)\")\n            if not prefix then\n                break\n            end\n\n            if prefix == suffix then\n                replaceText = prefix\n            elseif prefix == \",\" then\n                replaceText = suffix\n            elseif suffix == \",\" then\n                replaceText = prefix\n            elseif prefix == \"[\" and suffix == \"]\" then\n                replaceText = \"[]\"\n            end\n\n            -- sanitize prefix for regex if necessary\n            if prefix == \"[\" then\n                prefix = \"%[\"\n            end\n\n            containerList = string.gsub(containerList, prefix .. containerId .. suffix, replaceText)\n            changed = true\n        until not prefix\n\n        if changed then\n            databank.setStringValue(itemContainer, containerList)\n        end\n\n        ::continue::\n    end\nend\n\n--- Examines the databank, searching for duplicate keys, containers with multiple mappings, etc.\nlocal ITEM_CONTAINER_PATTERN = \".-%\" .. constants.CONTAINER_SUFFIX .. \"$\" -- escape \".\" prefix\nfunction _G.InventoryCommon.validateDb(databank)\n    local keyCount = {}\n    local containerCount = {}\n    for _, key in pairs(databank.getKeyList()) do\n        keyCount[key] = (keyCount[key] or 0) + 1\n\n        if string.match(key, ITEM_CONTAINER_PATTERN) then\n            for _, containerId in pairs(InventoryCommon.jsonToIntList(databank.getStringValue(key))) do\n                containerCount[containerId] = (containerCount[containerId] or 0) + 1\n            end\n        end\n    end\n    for key, count in pairs(keyCount) do\n        if count > 1 then\n            system.print(string.format(\"Duplicate key: %s (%d)\", key, count))\n        end\n    end\n    for containerId, count in pairs(containerCount) do\n        if count > 1 then\n            system.print(string.format(\"Duplicate container mapping: %s (%d)\", containerId, count))\n        end\n    end\nend\n\nreturn _G.InventoryCommon\n","filter":{"args":[],"signature":"onStart()","slotKey":"-5"},"key":"4"},
        {"code":"local concat = table.concat\nlocal sFormat=string.format\n\nlocal function internalSerialize(table, tC, t)\n    t[tC] = \"{\"\n    tC = tC + 1\n    if #table == 0 then\n        local hasValue = false\n        for key, value in pairs(table) do\n            hasValue = true\n            local keyType = type(key)\n            if keyType == \"string\" then\n                t[tC] = sFormat(\"[%q]=\", key)\n            elseif keyType == \"number\" then\n                t[tC] = \"[\" .. key .. \"]=\"\n            elseif keyType == \"boolean\" then\n                t[tC] = \"[\" .. tostring(key) .. \"]=\"\n            else\n                t[tC] = \"notsupported=\"\n            end\n            tC = tC + 1\n\n            local check = type(value)\n            if check == \"table\" then\n                tC = internalSerialize(value, tC, t)\n            elseif check == \"string\" then\n                t[tC] = sFormat(\"%q\", value)\n            elseif check == \"number\" then\n                t[tC] = value\n            elseif check == \"boolean\" then\n                t[tC] = tostring(value)\n            else\n                t[tC] = '\"Not Supported\"'\n            end\n            t[tC + 1] = \",\"\n            tC = tC + 2\n        end\n        if hasValue then\n            tC = tC - 1\n        end\n    else\n        for i = 1, #table do\n            local value = table[i]\n            local check = type(value)\n            if check == \"table\" then\n                tC = internalSerialize(value, tC, t)\n            elseif check == \"string\" then\n                t[tC] = sFormat(\"%q\", value)\n            elseif check == \"number\" then\n                t[tC] = value\n            elseif check == \"boolean\" then\n                t[tC] = tostring(value)\n            else\n                t[tC] = '\"Not Supported\"'\n            end\n            t[tC + 1] = \",\"\n            tC = tC + 2\n        end\n        tC = tC - 1\n    end\n    t[tC] = \"}\"\n    return tC\nend\n\nfunction serialize(value)\n    local t = {}\n    local check = type(value)\n\n    if check == \"table\" then\n        internalSerialize(value, 1, t)\n    elseif check == \"string\" then\n        return sFormat(\"%q\", value)\n    elseif check == \"number\" then\n        return value\n    elseif check == \"boolean\" then\n        return tostring(value)\n    else\n        return '\"Not Supported\"'\n    end\n\n    return concat(t)\nend\n\nfunction deserialize(s)\n    return load(\"return \" .. s)()\nend\n\n","filter":{"args":[],"signature":"onStart()","slotKey":"-5"},"key":"5"}
    ],
    "methods":[],
    "events":[]
}
