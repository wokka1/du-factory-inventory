{
    "slots":{
        "0":{"name":"slot1","type":{"events":[],"methods":[]}},
        "1":{"name":"slot2","type":{"events":[],"methods":[]}},
        "2":{"name":"slot3","type":{"events":[],"methods":[]}},
        "3":{"name":"slot4","type":{"events":[],"methods":[]}},
        "4":{"name":"slot5","type":{"events":[],"methods":[]}},
        "5":{"name":"slot6","type":{"events":[],"methods":[]}},
        "6":{"name":"slot7","type":{"events":[],"methods":[]}},
        "7":{"name":"slot8","type":{"events":[],"methods":[]}},
        "8":{"name":"slot9","type":{"events":[],"methods":[]}},
        "9":{"name":"slot10","type":{"events":[],"methods":[]}},
        "-1":{"name":"unit","type":{"events":[],"methods":[]}},
        "-2":{"name":"construct","type":{"events":[],"methods":[]}},
        "-3":{"name":"player","type":{"events":[],"methods":[]}},
        "-4":{"name":"system","type":{"events":[],"methods":[]}},
        "-5":{"name":"library","type":{"events":[],"methods":[]}}
    },
    "handlers":[
        {"code":"---------------------------------------\n-- Factory Inventory: Data Collector --\n--        By W3asel (1337joe)        --\n---------------------------------------\n-- Bundled: 2022-11-20T23:53:23Z\n-- Latest version always available here: https://du.w3asel.com/du-factory-inventory\n\nlocal waitTime = 31 --export: Time between container scans.\n\n-- localize global lookups\nlocal slots = {}\nslots.containers = {}\nlocal Utilities = _G.Utilities\nlocal InventoryCommon = _G.InventoryCommon\n\n-- if not found by name will autodetect\nslots.screen = screen\nslots.databank = databank\n\n-- link missing slot inputs / validate provided slots\nlocal module = \"inventory-report-scanner\"\nslots.screen = Utilities.loadSlot(slots.screen, \"ScreenUnit\", nil, module, \"screen\", true)\nslots.databank = Utilities.loadSlot(slots.databank, \"DataBankUnit\", slots.screen, module, \"databank\")\n\n-- clear screen, will be appending html to it as a debug output log\nif slots.screen then\n    slots.screen.setHTML(\"\")\n    slots.screen.activate()\nend\n\nlocal debugIndex = 0\nlocal debugFontSize = 2.5\nlocal function debugPrint(msg)\n    if slots.screen then\n        slots.screen.addText(0, debugIndex * debugFontSize, debugFontSize, msg)\n        debugIndex = debugIndex + 1\n    end\n    system.print(msg)\nend\n\nlocal nextContainer = nil\nlocal name\nlocal containerCount = 0\nrepeat\n    nextContainer, name = Utilities.findFirstSlot(\"Container%a+Group\", slots.containers)\n\n    if nextContainer ~= nil then\n        slots.containers[name] = nextContainer\n        containerCount = containerCount + 1\n    end\nuntil nextContainer == nil\nif containerCount == 0 then\n    local msg = \"Missing containers to register.\"\n    debugPrint(msg)\n    assert(false, msg)\nend\n\n-- initialize\nlocal containerStatus = {}\nfor _, container in pairs(slots.containers) do\n    containerStatus[container] = {\n        available = false,\n        complete = false,\n    }\nend\n\n-- define functions\nlocal function processContainer(container)\n    local itemsList = container.getContent()\n\n    local id = container.getLocalId()\n    local selfMass = container.getSelfMass()\n    local maxVolume = container.getMaxVolume()\n\n    InventoryCommon.removeContainerFromDb(slots.databank, id)\n\n    local itemData, name, quantity, unitMass, unitVolume, isMaterial\n    for _, item in pairs(itemsList) do\n        itemData = system.getItem(item.id)\n        if name then\n            debugPrint(string.format(\"Error: Multiple item types in container id %d: %s, %s, ...\", id, name, itemData.displayName));\n            containerStatus[container].complete = true\n            return\n        else\n            name = string.lower(itemData.displayName)\n            quantity = item.quantity\n            unitMass = itemData.unitMass\n            unitVolume = itemData.unitVolume\n            isMaterial = itemData.type == \"material\"\n        end\n    end\n    if not name then\n        debugPrint(string.format(\"Error: No items in container id %d\", id));\n        containerStatus[container].complete = true\n        return\n    end\n\n    -- itemName -> unitMass, unitVolume, isMaterial\n    -- itemName.containers -> [id, id, id, ...]\n    -- container.id -> selfMass, maxVolume, optimization\n\n    local itemDetails = {\n        unitMass = unitMass,\n        unitVolume = unitVolume,\n        isMaterial = isMaterial,\n    }\n    local itemString = json.encode(itemDetails)\n    slots.databank.setStringValue(name, itemString)\n\n    local itemContainersKey = name .. InventoryCommon.constants.CONTAINER_SUFFIX\n    local currentContainers = InventoryCommon.jsonToIntList(slots.databank.getStringValue(itemContainersKey))\n    table.insert(currentContainers, id)\n    slots.databank.setStringValue(itemContainersKey, InventoryCommon.intListToJson(currentContainers))\n\n    local density = container.getItemsMass() / quantity\n    local containerOptimization = density / unitMass\n    local containerKey = InventoryCommon.constants.CONTAINER_PREFIX .. id\n    local containerDetails = {\n        selfMass = selfMass,\n        maxVolume = maxVolume,\n        optimization = containerOptimization,\n    }\n    local containerString = json.encode(containerDetails)\n    slots.databank.setStringValue(containerKey, containerString)\n\n    debugPrint(string.format(\"Registered \\\"%s\\\" to container id: %d, optimization: %.2f\", name, id, containerOptimization))\n\n    containerStatus[container].complete = true\nend\n\nfunction _G.updateTick()\n    for _, container in pairs(slots.containers) do\n        if not containerStatus[container].available then\n            container.updateContent()\n            break\n        end\n    end\n\n    local incomplete = false\n    for _, container in pairs(slots.containers) do\n        if not containerStatus[container].complete then\n            if containerStatus[container].available then\n                processContainer(container)\n            else\n                incomplete = true\n            end\n        end\n    end\n\n    if not incomplete then\n        debugPrint(\"All containers complete, ending from timer.\")\n        InventoryCommon.validateDb(slots.databank)\n        unit.exit()\n    end\nend\n\nfunction _G.contentUpdated(slot)\n    containerStatus[slots.containers[slot]].available = true\n\n    _G.updateTick()\nend\n\nunit.setTimer(\"update\", waitTime)\n_G.updateTick()\n","filter":{"args":[],"signature":"onStart()","slotKey":"-1"},"key":"0"},
        {"code":"_G.updateTick()","filter":{"args":[{"value":"update"}],"signature":"tick(timerId)","slotKey":"-1"},"key":"1"},
        {"code":"_G.contentUpdated(\"slot1\")","filter":{"args":[],"signature":"onContentUpdate()","slotKey":"0"},"key":"2"},
        {"code":"_G.contentUpdated(\"slot2\")","filter":{"args":[],"signature":"onContentUpdate()","slotKey":"1"},"key":"3"},
        {"code":"_G.contentUpdated(\"slot3\")","filter":{"args":[],"signature":"onContentUpdate()","slotKey":"2"},"key":"4"},
        {"code":"_G.contentUpdated(\"slot4\")","filter":{"args":[],"signature":"onContentUpdate()","slotKey":"3"},"key":"5"},
        {"code":"_G.contentUpdated(\"slot5\")","filter":{"args":[],"signature":"onContentUpdate()","slotKey":"4"},"key":"6"},
        {"code":"_G.contentUpdated(\"slot6\")","filter":{"args":[],"signature":"onContentUpdate()","slotKey":"5"},"key":"7"},
        {"code":"_G.contentUpdated(\"slot7\")","filter":{"args":[],"signature":"onContentUpdate()","slotKey":"6"},"key":"8"},
        {"code":"_G.contentUpdated(\"slot8\")","filter":{"args":[],"signature":"onContentUpdate()","slotKey":"7"},"key":"9"},
        {"code":"_G.contentUpdated(\"slot9\")","filter":{"args":[],"signature":"onContentUpdate()","slotKey":"8"},"key":"10"},
        {"code":"_G.contentUpdated(\"slot10\")","filter":{"args":[],"signature":"onContentUpdate()","slotKey":"9"},"key":"11"},
        {"code":"--- Utilities module.\n-- Frequently needed utility functions.\n-- @module Utilities\n\n-- Guard to keep this module from reinitializing any time the start event fires if placed in libraries/system slot.\nif _G.Utilities then\n    return\nend\n_G.Utilities = {}\n\nlocal SI_PREFIXES = {\"\", \"k\", \"M\", \"G\", \"T\", \"P\", \"E\", \"Z\", \"Y\"}\n--- Converts raw float to formatted SI prefix with limited decimal places.\n-- @tparam number value The number to format.\n-- @tparam string units The units label to apply SI prefixes to.\n-- @treturn string The formated number for display.\n-- @treturn string The units with SI prefix applied.\nfunction _G.Utilities.printableNumber(value, units)\n    -- can't process nil, 0 breaks the sign calculation\n    if not value or value == 0 then\n        return \"0.0\", units\n    end\n\n    local adjustedValue = math.abs(value)\n    local sign = value / adjustedValue\n    local factor = 1 -- index of no prefix\n    while adjustedValue >= 999.5 and factor < #SI_PREFIXES do\n        adjustedValue = adjustedValue / 1000\n        factor = factor + 1\n    end\n\n    if adjustedValue < 9.95 then -- rounded to 10, show 1 decimal place\n        return string.format(\"%.1f\", sign * math.floor(adjustedValue * 10 + 0.5) / 10), SI_PREFIXES[factor] .. units\n    end\n    return string.format(\"%.0f\", sign * math.floor(adjustedValue + 0.5)), SI_PREFIXES[factor] .. units\nend\n\n--- Finds the first slot on 'unit' that has element class 'slotClass' and is not listed in the exclude list.\n-- @tparam string slotClass The element class pattern of the target slot. May instead be a table containing a list of\n--   class names.\n-- @tparam table exclude A list of slots to exclude from search.\n-- @return The first element found of the desired type, or nil if none is found.\n-- @return The name of the slot where the returned element was found.\nfunction _G.Utilities.findFirstSlot(slotClass, exclude)\n    if type(slotClass) ~= \"table\" then\n        slotClass = {slotClass}\n    end\n    exclude = exclude or {}\n\n    for key, value in pairs(unit) do\n\n        -- ignore excluded elements\n        for _, exc in pairs(exclude) do\n            if value == exc then\n                goto continueOuter\n            end\n        end\n\n        if value and type(value) == \"table\" and value.getClass then\n            for _, class in pairs(slotClass) do\n                if string.match(value.getClass(), class) ~= nil then\n                    return value, key\n                end\n            end\n        end\n\n        ::continueOuter::\n    end\n\n    return nil, nil\nend\n\n-- Verifies the valid argument, if not true then it prints the provided message to the optional screen and to the programming board error log, halting execution.\n-- @param valid The condition to test, typically a boolean.\n-- @tparam string message The message to display on failure.\n-- @tparam ScreenUnit/ScreenSignUnit screen The optional screen for displaying the message on in case of failure.\nlocal function assertValid(valid, message, screen)\n    if not valid then\n        if screen and screen.setCenteredText and type(screen.setCenteredText) == \"function\" then\n            screen.setCenteredText(message)\n        end\n        error(message)\n    end\nend\n\n--- Attempts to verify the provided slot against the expected type, finding missing slot inputs in unit.\n-- @tparam Element provided A named slot that should fill the need for this type. May be nil.\n-- @tparam string targetClass The ElementClass to look for/validate against. May be a table containing a list of classes.\n-- @tparam ScreenUnit/ScreenSignUnit errorScreen A screen to display error messages to on failure.\n-- @tparam string moduleName The name of the module, to help disambiguate problems when multiple modules are run on the same controller.\n-- @tparam string mappedSlotName The internal name of the slot to indicate exactly what mapping failed.\n-- @tparam boolean optional True if this element is optional and should not produce an error on failure to map.\n-- @tparam string optionalMessage A message to print to the console on failure to map an optional element.\nfunction _G.Utilities.loadSlot(provided, targetClass, errorScreen, moduleName, mappedSlotName, optional, optionalMessage)\n    if type(targetClass) ~= \"table\" then\n        targetClass = {targetClass}\n    end\n    local slotName\n\n    local typedSlot = provided\n    if not (typedSlot and type(typedSlot) == \"table\" and typedSlot.getClass) then\n        typedSlot, slotName = _G.Utilities.findFirstSlot(targetClass)\n        if not optional then\n            assertValid(typedSlot, string.format(\"%s: %s link not found.\", moduleName, mappedSlotName), errorScreen)\n        end\n\n        if typedSlot then\n            system.print(string.format(\"Slot %s mapped to %s %s.\", slotName, moduleName, mappedSlotName))\n        elseif optionalMessage and string.len(optionalMessage) > 0 then\n            system.print(string.format(\"%s: %s\", moduleName, optionalMessage))\n        end\n    else\n        local class = typedSlot.getClass()\n        local valid = false\n        for _, tClass in pairs(targetClass) do\n            valid = valid or class == tClass\n        end\n        assertValid(valid, string.format(\"%s %s slot is of type: %s\", moduleName, mappedSlotName, class), errorScreen)\n    end\n    return typedSlot\nend\n\nlocal useParameterSettings = false --export: Toggle this on to override stored preferences with parameter-set values, otherwise will load from databank if available.\n-- can't export value from table, but would rather use it from the utilities object\n_G.Utilities.USE_PARAMETER_SETTINGS = useParameterSettings\n\n--- Returns the preferred preference value, storing that in the databank for future use if available. Type will be inferred from the default value provided.\n-- @param databank The databank to use for preferences.\n-- @tparam string key The databank preference key to look up/store to.\n-- @param defaultValue The value to use if the databank doesn't contain key.\n-- @return The preference value to use.\nfunction _G.Utilities.getPreference(databank, key, defaultValue)\n    local isBool = type(defaultValue) == \"boolean\"\n    local isNumber = type(defaultValue) == \"number\"\n    local prefValue\n\n    if databank then\n        if databank.hasKey(key) == 1 and not _G.Utilities.USE_PARAMETER_SETTINGS then\n            if isBool then\n                prefValue = databank.getIntValue(key) == 1\n            elseif isNumber then\n                prefValue = databank.getFloatValue(key)\n            else\n                prefValue = databank.getStringValue(key)\n            end\n        else\n            prefValue = defaultValue\n        end\n\n        if isBool then\n            local storeValue = 0\n            if prefValue then\n                storeValue = 1\n            end\n            databank.setIntValue(key, storeValue)\n        elseif isNumber then\n            databank.setFloatValue(key, tonumber(prefValue))\n        else\n            databank.setStringValue(key, prefValue)\n        end\n    else\n        prefValue = defaultValue\n    end\n\n    return prefValue\nend\n\nreturn _G.Utilities\n","filter":{"args":[],"signature":"onStart()","slotKey":"-5"},"key":"12"},
        {"code":"--- Common definitions for inventory system.\n\n-- Guard to keep this module from reinitializing any time the start event fires if placed in libraries/system slot.\nif _G.InventoryCommon then\n    return\nend\n_G.InventoryCommon = {}\n\nlocal constants = {}\n-- Container status will be read from core.\nconstants.SOURCE_CORE_CONTAINER = \"core container\"\n-- Container status will be read directly from container by volume.\nconstants.SOURCE_CONTAINER_VOLUME_ONLY = \"container volume\"\n-- suffix of item container keys, format \"<item name>.c\"\nconstants.CONTAINER_SUFFIX = \".c\"\n-- prefix for container metadata keys, format \"c.<id>\"\nconstants.CONTAINER_PREFIX = \"c.\"\n_G.InventoryCommon.constants = constants\n\nfunction _G.InventoryCommon.jsonToIntList(json)\n    local listElements = {}\n\n    for element in string.gmatch(json, \"%d+\") do\n        listElements[#listElements + 1] = tonumber(element)\n    end\n\n    return listElements\nend\n\nfunction _G.InventoryCommon.intListToJson(list)\n    return string.format(\"[%s]\", table.concat(list, \",\"))\nend\n\nlocal CONTAINERS_DB_PATTERN = string.format([[.+%%%s]], constants.CONTAINER_SUFFIX) -- escape . in suffix\n--- Strips the provided container id out of any items that have it listed.\nfunction _G.InventoryCommon.removeContainerFromDb(databank, containerId)\n    local containerList, prefix, suffix, replaceText, changed\n    for _, itemContainer in pairs(databank.getKeyList()) do\n        if not string.match(itemContainer, CONTAINERS_DB_PATTERN) then\n            goto continue\n        end\n        containerList = databank.getStringValue(itemContainer)\n\n        changed = false\n        repeat\n            prefix, suffix = string.match(containerList, \"(%D)%s*\" .. containerId .. \"%s*(%D)\")\n            if not prefix then\n                break\n            end\n\n            if prefix == suffix then\n                replaceText = prefix\n            elseif prefix == \",\" then\n                replaceText = suffix\n            elseif suffix == \",\" then\n                replaceText = prefix\n            elseif prefix == \"[\" and suffix == \"]\" then\n                replaceText = \"[]\"\n            end\n\n            -- sanitize prefix for regex if necessary\n            if prefix == \"[\" then\n                prefix = \"%[\"\n            end\n\n            containerList = string.gsub(containerList, prefix .. containerId .. suffix, replaceText)\n            changed = true\n        until not prefix\n\n        if changed then\n            databank.setStringValue(itemContainer, containerList)\n        end\n\n        ::continue::\n    end\nend\n\n--- Examines the databank, searching for duplicate keys, containers with multiple mappings, etc.\nlocal ITEM_CONTAINER_PATTERN = \".-%\" .. constants.CONTAINER_SUFFIX .. \"$\" -- escape \".\" prefix\nfunction _G.InventoryCommon.validateDb(databank)\n    local keyCount = {}\n    local containerCount = {}\n    for _, key in pairs(databank.getKeyList()) do\n        keyCount[key] = (keyCount[key] or 0) + 1\n\n        if string.match(key, ITEM_CONTAINER_PATTERN) then\n            for _, containerId in pairs(InventoryCommon.jsonToIntList(databank.getStringValue(key))) do\n                containerCount[containerId] = (containerCount[containerId] or 0) + 1\n            end\n        end\n    end\n    for key, count in pairs(keyCount) do\n        if count > 1 then\n            system.print(string.format(\"Duplicate key: %s (%d)\", key, count))\n        end\n    end\n    for containerId, count in pairs(containerCount) do\n        if count > 1 then\n            system.print(string.format(\"Duplicate container mapping: %s (%d)\", containerId, count))\n        end\n    end\nend\n\nreturn _G.InventoryCommon\n","filter":{"args":[],"signature":"onStart()","slotKey":"-5"},"key":"13"}
    ],
    "methods":[],
    "events":[]
}
